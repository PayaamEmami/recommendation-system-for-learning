@page "/feeds"
@using Microsoft.AspNetCore.Components.Web
@using Rsl.Core.Enums
@inject AuthService AuthService
@inject FeedService FeedService
@inject SourceService SourceService
@inject XFeedService XFeedService
@inject ThemeService ThemeService
@inject NavigationManager Navigation
@implements IDisposable

<PageTitle>My Feed - RSL</PageTitle>

<div class="page-container">
    <div class="x-feed-container">
        <div class="x-feed-header">
            <div>
                <h2>X Feed</h2>
                <p class="subtitle">Latest posts from accounts you follow</p>
            </div>
            <div class="x-feed-actions">
                <button class="btn-secondary" @onclick="ConnectXAsync" disabled="@_xConnecting">
                    @_xConnectButtonLabel
                </button>
                <button class="btn-secondary" @onclick="RefreshXAsync" disabled="@_xLoading">
                    Refresh
                </button>
            </div>
        </div>

        @if (!string.IsNullOrEmpty(_xError))
        {
            <div class="x-feed-error">@_xError</div>
        }

        @if (_xLoading)
        {
            <p>Loading X feed...</p>
        }
        else if (!_followedAccounts.Any())
        {
            <div class="x-empty-state">
            </div>
        }
        else
        {
            <div class="x-followed-list">
                <div class="x-followed-header">
                    <h3>Select accounts to include</h3>
                    <button class="btn-primary" @onclick="SaveSelectionsAsync" disabled="@_xSavingSelections">
                        Save Selection
                    </button>
                </div>
                <div class="x-followed-grid">
                    @foreach (var account in _followedAccounts)
                    {
                        <label class="x-followed-item">
                            <input type="checkbox"
                                   checked="@_selectedAccountIds.Contains(account.Id)"
                                   @onchange="(e) => ToggleSelected(account.Id, e)" />
                            <img src="@account.ProfileImageUrl" alt="@account.Handle" />
                            <div>
                                <div class="x-followed-name">@account.DisplayName</div>
                                <div class="x-followed-handle">@($"@{account.Handle}")</div>
                            </div>
                        </label>
                    }
                </div>
            </div>

            <div class="x-post-carousel">
                @if (!_posts.Any())
                {
                    <p class="x-empty-state">No posts available yet. Try refreshing after the next ingest.</p>
                }
                else
                {
                    @foreach (var post in _posts)
                    {
                        <div class="x-post-card">
                            <div class="x-post-header">
                                <img src="@post.AuthorProfileImageUrl" alt="@post.AuthorHandle" />
                                <div>
                                    <div class="x-post-author">@post.AuthorName</div>
                                    <div class="x-post-handle">@($"@{post.AuthorHandle}")</div>
                                </div>
                            </div>
                            <div class="x-post-text">@post.Text</div>
                            @if (!string.IsNullOrEmpty(GetPostMediaUrl(post)))
                            {
                                <img class="x-post-media" src="@GetPostMediaUrl(post)" alt="Post media" />
                            }
                            <div class="x-post-meta">
                                <span>@FormatDate(post.PostCreatedAt)</span>
                                <span>‚ù§ @post.LikeCount</span>
                                <span>üí¨ @post.ReplyCount</span>
                                <span>üîÅ @post.RepostCount</span>
                            </div>
                            <a class="x-post-link" href="@post.Url" target="_blank" rel="noopener">View on X</a>
                        </div>
                    }
                }
            </div>
        }
    </div>

    <div class="feed-container">
        @if (_resources == null)
        {
            <p>Loading feed...</p>
        }
        else if (!_resources.Any())
        {
            @if (_sources == null)
            {
                <p>Checking your sources...</p>
            }
            else if (!_sources.Any())
            {
                <div class="empty-state" style="text-align: center; padding: 3rem 1rem;">
                    <h2 style="margin-bottom: 1rem; color: var(--text-primary);">No Sources Yet</h2>
                    <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">
                        Start by adding some learning sources like RSS feeds, YouTube channels, or blogs.
                    </p>
                    <p style="margin-bottom: 2rem; color: var(--text-secondary);">
                        Our system will automatically fetch content daily and show personalized recommendations here.
                    </p>
                    <a href="/sources" class="btn-primary">Add Your First Source</a>
                </div>
            }
            else
            {
                <div class="empty-state" style="text-align: center; padding: 3rem 1rem;">
                    <h2 style="margin-bottom: 1rem; color: var(--text-primary);">Processing Your Sources</h2>
                    <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">
                        You have @_sources.Count source@(_sources.Count == 1 ? "" : "s") configured. Our system is working on fetching and analyzing content.
                    </p>
                    <p style="margin-bottom: 2rem; color: var(--text-secondary);">
                        This process runs automatically every 24 hours. Check back soon for personalized recommendations!
                    </p>
                    <a href="/sources" class="btn-primary">Manage Sources</a>
                </div>
            }
        }
        else
        {
            <div class="feed-sections">
                @foreach (var type in Enum.GetValues<ResourceType>())
                {
                    var resourcesOfType = _resourcesByType.ContainsKey(type) ? _resourcesByType[type] : new List<ResourceItem>();

                    @if (resourcesOfType.Any())
                    {
                        <div class="feed-section">
                            <h2 class="section-title">@GetResourceTypeDisplay(type)</h2>
                            <div class="resource-table">
                                @foreach (var resource in resourcesOfType)
                                {
                                    <div class="resource-row">
                                        <div class="resource-vote-controls">
                                            <button class="vote-btn vote-up @(GetVoteState(resource.Id) == VoteType.Upvote ? "active" : "")"
                                                    @onclick="() => HandleVote(resource.Id, VoteType.Upvote)"
                                                    disabled="@_votingResourceId.HasValue"
                                                    title="Upvote">
                                                <span class="vote-icon">‚ñ≤</span>
                                            </button>
                                            <button class="vote-btn vote-down @(GetVoteState(resource.Id) == VoteType.Downvote ? "active" : "")"
                                                    @onclick="() => HandleVote(resource.Id, VoteType.Downvote)"
                                                    disabled="@_votingResourceId.HasValue"
                                                    title="Downvote">
                                                <span class="vote-icon">‚ñº</span>
                                            </button>
                                        </div>
                                        <div class="resource-content">
                                            <div class="resource-meta">
                                                <span class="resource-type-badge">@GetResourceTypeBadge(resource.Type)</span>
                                                <span class="resource-date">@FormatDate(resource.PublishedAt)</span>
                                            </div>
                                            <h3 class="resource-row-title">
                                                <a href="@resource.Url" target="_blank" rel="noopener">@resource.Title</a>
                                            </h3>
                                            @if (!string.IsNullOrEmpty(resource.Description))
                                            {
                                                <p class="resource-row-description">@resource.Description</p>
                                            }
                                        </div>
                                        <div class="resource-actions">
                                            <a href="@resource.Url" target="_blank" rel="noopener" class="resource-open-btn" title="Open resource">
                                                ‚Üó
                                            </a>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                }
            </div>
        }
    </div>
</div>

@code {
    private List<ResourceItem>? _resources;
    private List<SourceItem>? _sources;
    private Dictionary<ResourceType, List<ResourceItem>> _resourcesByType = new();
    private Dictionary<Guid, VoteType> _userVotes = new();
    private Guid? _votingResourceId;
    private List<XFollowedAccountItem> _followedAccounts = new();
    private HashSet<Guid> _selectedAccountIds = new();
    private List<XPostItem> _posts = new();
    private bool _xLoading = true;
    private bool _xConnecting;
    private bool _xSavingSelections;
    private string? _xError;
    private string _xConnectButtonLabel = "Connect X";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ThemeService.InitializeAsync();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await AuthService.InitializeAsync();

        if (!AuthService.CurrentState.IsAuthenticated)
        {
            Navigation.NavigateTo("/login");
            return;
        }

        AuthService.OnAuthStateChanged += HandleAuthStateChanged;
        await LoadXSection();
        await LoadFeed();
    }

    private async Task LoadXSection()
    {
        _xLoading = true;
        _xError = null;

        try
        {
            _followedAccounts = await XFeedService.GetFollowedAccountsAsync(false);
            _selectedAccountIds = _followedAccounts
                .Where(a => a.IsSelected)
                .Select(a => a.Id)
                .ToHashSet();
            _xConnectButtonLabel = _followedAccounts.Any() ? "Reconnect X" : "Connect X";
            _posts = await XFeedService.GetPostsAsync(30);
        }
        catch (Exception ex)
        {
            _xError = $"Failed to load X feed: {ex.Message}";
        }
        finally
        {
            _xLoading = false;
            StateHasChanged();
        }
    }

    private async Task ConnectXAsync()
    {
        _xConnecting = true;
        _xError = null;

        var redirectUri = new Uri(new Uri(Navigation.BaseUri), "x/callback").ToString();
        var url = await XFeedService.GetConnectUrlAsync(redirectUri);
        if (string.IsNullOrEmpty(url))
        {
            _xError = "Unable to start X connection. Please try again.";
            _xConnecting = false;
            return;
        }

        Navigation.NavigateTo(url, forceLoad: true);
    }

    private async Task RefreshXAsync()
    {
        _xLoading = true;
        _xError = null;

        try
        {
            _followedAccounts = await XFeedService.GetFollowedAccountsAsync(true);
            _selectedAccountIds = _followedAccounts
                .Where(a => a.IsSelected)
                .Select(a => a.Id)
                .ToHashSet();
            _xConnectButtonLabel = _followedAccounts.Any() ? "Reconnect X" : "Connect X";
            _posts = await XFeedService.GetPostsAsync(30);
        }
        catch (Exception ex)
        {
            _xError = $"Failed to refresh X data: {ex.Message}";
        }
        finally
        {
            _xLoading = false;
        }
    }

    private async Task SaveSelectionsAsync()
    {
        _xSavingSelections = true;
        _xError = null;

        try
        {
            var updated = await XFeedService.UpdateSelectedAccountsAsync(_selectedAccountIds.ToList());
            _followedAccounts = updated;
            _selectedAccountIds = _followedAccounts
                .Where(a => a.IsSelected)
                .Select(a => a.Id)
                .ToHashSet();
            _posts = await XFeedService.GetPostsAsync(30);
        }
        catch (Exception ex)
        {
            _xError = $"Failed to update selections: {ex.Message}";
        }
        finally
        {
            _xSavingSelections = false;
        }
    }

    private void ToggleSelected(Guid id, ChangeEventArgs args)
    {
        var isChecked = args.Value is bool value && value;
        if (isChecked)
        {
            _selectedAccountIds.Add(id);
        }
        else
        {
            _selectedAccountIds.Remove(id);
        }
    }

    private static string? GetPostMediaUrl(XPostItem post)
    {
        if (string.IsNullOrEmpty(post.MediaJson))
        {
            return null;
        }

        try
        {
            var media = System.Text.Json.JsonSerializer.Deserialize<List<XMediaInfo>>(post.MediaJson);
            var first = media?.FirstOrDefault();
            return first?.Url ?? first?.PreviewImageUrl;
        }
        catch
        {
            return null;
        }
    }

    private async Task LoadFeed()
    {
        _resources = await FeedService.GetFeedAsync(null);

        // Group resources by type
        if (_resources != null && _resources.Any())
        {
            _resourcesByType = _resources
                .GroupBy(r => r.Type)
                .ToDictionary(g => g.Key, g => g.ToList());

            // Load user votes for all resources
            await LoadUserVotes();
        }
        else
        {
            _resourcesByType = new Dictionary<ResourceType, List<ResourceItem>>();
        }

        // Only check for sources if we have no resources to show appropriate message
        if (_resources == null || !_resources.Any())
        {
            _sources = await SourceService.GetUserSourcesAsync();
        }

        StateHasChanged();
    }

    private async Task LoadUserVotes()
    {
        if (_resources == null) return;

        var votes = await FeedService.GetUserVotesAsync();
        _userVotes = votes.ToDictionary(v => v.ResourceId, v => v.VoteType);
    }

    private VoteType? GetVoteState(Guid resourceId)
    {
        return _userVotes.TryGetValue(resourceId, out var voteType) ? voteType : null;
    }

    private async Task HandleVote(Guid resourceId, VoteType voteType)
    {
        if (_votingResourceId.HasValue) return;

        _votingResourceId = resourceId;
        StateHasChanged();

        try
        {
            var currentVote = GetVoteState(resourceId);

            if (currentVote == voteType)
            {
                // Remove vote if clicking the same button
                var success = await FeedService.RemoveVoteAsync(resourceId);
                if (success)
                {
                    _userVotes.Remove(resourceId);
                }
            }
            else
            {
                // Cast or update vote
                var result = await FeedService.VoteAsync(resourceId, voteType);
                if (result != null)
                {
                    _userVotes[resourceId] = result.VoteType;
                }
            }
        }
        finally
        {
            _votingResourceId = null;
            StateHasChanged();
        }
    }

    private void HandleAuthStateChanged()
    {
        if (!AuthService.CurrentState.IsAuthenticated)
        {
            Navigation.NavigateTo("/login");
        }
    }

    private static string GetResourceTypeDisplay(ResourceType type)
    {
        return type switch
        {
            ResourceType.Paper => "Papers",
            ResourceType.Video => "Videos",
            ResourceType.BlogPost => "Blogs",
            _ => type.ToString()
        };
    }

    private static string GetResourceTypeBadge(ResourceType type)
    {
        return type switch
        {
            ResourceType.Paper => "üìÑ",
            ResourceType.Video => "üé¨",
            ResourceType.BlogPost => "üìù",
            _ => "üìé"
        };
    }

    private static string FormatDate(DateTime date)
    {
        var span = DateTime.UtcNow - date;

        if (span.TotalDays < 1)
            return $"{(int)span.TotalHours}h ago";
        if (span.TotalDays < 7)
            return $"{(int)span.TotalDays}d ago";
        if (span.TotalDays < 30)
            return $"{(int)(span.TotalDays / 7)}w ago";

        return date.ToString("MMM d, yyyy");
    }

    private class XMediaInfo
    {
        public string Type { get; set; } = string.Empty;
        public string? Url { get; set; }
        public string? PreviewImageUrl { get; set; }
    }

    public void Dispose()
    {
        AuthService.OnAuthStateChanged -= HandleAuthStateChanged;
    }
}
